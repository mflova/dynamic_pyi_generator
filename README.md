# LazyTypeHint

Type hint any Python (nested) data structure! Dictionaries, callables, Pandas DataFrames,
numpy arrays...

```
pip install lazy-type-hint
```

Some quick examples you can try:
```py
from lazy_type_hint import LazyTypeHint, LazyTypeHintLive

data = ({"name": "Peter", "age": 22},)
LazyTypeHint().from_data(data, class_name="MyClass").to_file("file.py")
LazyTypeHint().from_data(data, class_name="MyClass").to_string()
data_type_hinted = LazyTypeHintLive().from_data(data, class_name="MyClass")
```

## Tools

All tools support generating type hints...
 - `from_data`: Type hint any Python built-in data structures and more. These include big
   or deep nested structures, normal/multiindex Pandas DataFrames or numpy arrays.
 - `from_yaml_file`: Performs same as `from_data`. However, if comments are found within
   the YAML file, these will be parsed as docstrings.
   
In addition, all of them support a wide range of input parameters in the initializer in
order to fine tune type hint generation or to validate your data structures.

### LazyTypeHintLive

Type hint any data structure in a single line and reuse it out of the box after the code
is executed once. The original data and its class always remains untouched, as this only
affects at type hint level

```py
from lazy_type_hint import LazyTypeHintLive

data = ({"name": "Peter", "age": 22},)
data_type_hinted = LazyTypeHintLive().from_data(data, class_name="Data")
# After executing this snippet, an interface `Data` is locally created and
# can be reused anywhere in any other file as long as `class_name="Data"`
#
# `LazyTypeHintLive.reset()` will erase all type hints created by this class.
```

Out of the box and only with this line, this will allow you to:

|       |       |
|:-------------:|:-------------:|
| Perform static analysis to detect issues | ![After executing the code](https://github.com/mflova/lazy-type-hint/assets/67102627/ebd3f488-e3b5-400f-abd7-fccab7063773) |
| Have full autocompletion support from your IDE | ![After executing the code](https://github.com/mflova/lazy-type-hint/assets/67102627/46c0ff38-9332-4795-b36c-86e8086eeaef) |


### LazyTypeHint

This tool will also generate type hints for any given data. The difference with respect to
`LazyTypeHintLive` is that this one will allow you to manage them on your own. By using
`to_file()` method you can export an importable module that can be used to type hint and
update your data structures at any moment.

```py
from lazy_type_hint import LazyTypeHint

data = {"name": "Peter", "age": 22}
LazyTypeHint().from_data(data, class_name="Data").to_string()
LazyTypeHint().from_data(data, class_name="Data").to_file("my_file.py")
```

## When this tool can be useful?

As said before, type hinting your input/output data structures makes it easier for
developers since it gives you extra IDE information in order to develop code and detect
extra issues. While developing code I realized that keeping up to date type hints of some
data structures is boring and error prone. Whenever they are updated, a person must
remember to update it. The target of this tool is to enjoy the advantages of type hinted
data structures without having to worry about it.

## What makes it a different tool?

There are some tools that aim to perform something similar. `Cattrs` or `pydantic` require
knowing the structure beforehand. Then, the developer is responsible for writing it. They
are validation-oriented. This tool is more geared towards providing better type hints in
an automated way and ensuring that the structure is accessed correctly. Although other
tools such as `Stubgen` are able to generate `.pyi` files in an automated way, it might be
required to edit the environment to indicate where these stub-based files are located.

## How does it work?

Both tools parse the data structure to a tree-based data structure. Each node represents a
different type or container (`list`, `dict`...). This tree will allow to 1) detect and
simplify equal nodes from the point of view of type hinting, 2) perform similarity based
merges or 3) have full control of how each type alias is generated.

On top of that, `LazyTypeHintLive` will locally update its own internal API and its `pyi`
files to include or remove new type hints generated by the tree mentioned above. This
feature allows the user to use its own type hints without having to manage anything
related to its files.

## All features

Main features:
 - Type hint any (nested) structure.
 - Validate structures by comparising its string representation via `LazyTypeHintLive`
 - Dictionaries can be type hinted as `TypedDict`, meaning that the IDE will have extra
   information about its underlying structures. Developer can therefore benefit from extra
   static analysis or autcomplete features.
 - Similarity based merge:
   - Equal (nested) structures will be detected as such and type hinted under the same type alias.
   - Similar structures such as dictionaries will be merged indicating which keys were
     found to be not mandatory or required.
 - Type hint structures within any given file (YAML, JSON...).
 - Document structures:
    - Specify a specific keyword within dictionaries that will be parsed and
      included as a docstring.
    - Some file format such as like YAML will also find and parse comments as docstrings.
 - Wide range of type hint based on strategies. The user can select at any time: 
   - Which kind of container is prefered (`Sequence`/`list`)
   - How to type hint a tuple (either with fixed or non-fixed size)
   - The complexity of the type aliases to be created.
   - Dictionaries typed as `Mapping`, `Dict` or `TypedDict`
   - Minimum percentage of similarity between dicts to be merged.
   - Mutable or read-only based `TypedDict`.
 
Structures that can be type hinted:
 - Sequence based: `list`, `tuple`
 - Set based: `set`, `frozenset`
 - Mapping based: `dict`, `MappingProxyType`
 - Simple built-in types: `bool`, `int`, `float`, `range`, `slice`, `None`, `str`
 - Callables: `lambda`, functions, `staticmethod`, `classmethod`, built-in functions
 - `ModuleType`
 - `IOBase`
 - `Iterator`
 - Custom objects: instances and classes
 - `Pandas` based structures: Including `DataFrame` (with `MultiIndex` and `Index`) and
   `Series`.
 - `numpy` arrays